#!/usr/bin/env python3
"""
Telegram –±–æ—Ç –¥–ª—è –∞–±–∏—Ç—É—Ä–∏–µ–Ω—Ç–æ–≤ –ò–¢–ú–û
–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å BotHandler –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
"""

import logging
import os
import sys
from typing import Dict, List, Optional

from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    ContextTypes,
    filters
)

# –î–æ–±–∞–≤–ª—è–µ–º –∫–æ—Ä–Ω–µ–≤—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –≤ path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from src.bot.bot_handler import BotHandler
from config import TELEGRAM_BOT_TOKEN

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler('logs/telegram_bot.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class ITMOTelegramBot:
    def __init__(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram –±–æ—Ç–∞"""
        self.bot_handler = BotHandler()
        self.application = None
        
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /start"""
        user = update.effective_user
        user_id = user.id
        username = user.username or user.first_name
        
        logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {username} ({user_id}) –∑–∞–ø—É—Å—Ç–∏–ª –±–æ—Ç–∞")
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —á–µ—Ä–µ–∑ –Ω–∞—à BotHandler
        response = self.bot_handler.process_message(user_id, username, "/start")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
        await self.send_response(update, response)
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /help"""
        user = update.effective_user
        response = self.bot_handler.process_message(user.id, user.username, "/help")
        await self.send_response(update, response)
    
    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        user = update.effective_user
        message_text = update.message.text
        
        logger.info(f"–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç {user.username} ({user.id}): {message_text}")
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —á–µ—Ä–µ–∑ –Ω–∞—à BotHandler
        response = self.bot_handler.process_message(user.id, user.username, message_text)
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
        await self.send_response(update, response)
    
    async def send_response(self, update: Update, response: Dict) -> None:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é"""
        try:
            text = response.get('text', '–ù–µ—Ç –æ—Ç–≤–µ—Ç–∞')
            keyboard_data = response.get('keyboard', [])
            
            # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –µ—Å–ª–∏ –µ—Å—Ç—å
            reply_markup = None
            if keyboard_data:
                reply_markup = ReplyKeyboardMarkup(
                    keyboard_data,
                    resize_keyboard=True,
                    one_time_keyboard=False
                )
            
            # –†–∞–∑–±–∏–≤–∞–µ–º –¥–ª–∏–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –Ω–∞ —á–∞—Å—Ç–∏ (Telegram –ª–∏–º–∏—Ç 4096 —Å–∏–º–≤–æ–ª–æ–≤)
            max_message_length = 4000
            
            if len(text) <= max_message_length:
                await update.message.reply_text(
                    text,
                    reply_markup=reply_markup
                    # –£–±–∏—Ä–∞–µ–º parse_mode —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–æ–∫ —Ä–∞–∑–º–µ—Ç–∫–∏
                )
            else:
                # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ —á–∞—Å—Ç–∏
                parts = self.split_message(text, max_message_length)
                
                for i, part in enumerate(parts):
                    # –ö–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∫ –ø–æ—Å–ª–µ–¥–Ω–µ–º—É —Å–æ–æ–±—â–µ–Ω–∏—é
                    current_markup = reply_markup if i == len(parts) - 1 else None
                    
                    await update.message.reply_text(
                        part,
                        reply_markup=current_markup
                        # –£–±–∏—Ä–∞–µ–º parse_mode —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–æ–∫ —Ä–∞–∑–º–µ—Ç–∫–∏
                    )
                    
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –æ—Ç–≤–µ—Ç–∞: {e}")
            await update.message.reply_text(
                "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
            )
    
    def split_message(self, text: str, max_length: int) -> List[str]:
        """–†–∞–∑–±–∏–≤–∫–∞ –¥–ª–∏–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–∞ —á–∞—Å—Ç–∏"""
        if len(text) <= max_length:
            return [text]
        
        parts = []
        current_part = ""
        
        # –†–∞–∑–±–∏–≤–∞–µ–º –ø–æ –∞–±–∑–∞—Ü–∞–º
        paragraphs = text.split('\n\n')
        
        for paragraph in paragraphs:
            if len(current_part + paragraph + '\n\n') <= max_length:
                current_part += paragraph + '\n\n'
            else:
                if current_part:
                    parts.append(current_part.strip())
                    current_part = ""
                
                # –ï—Å–ª–∏ —Å–∞–º –ø–∞—Ä–∞–≥—Ä–∞—Ñ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π, —Ä–∞–∑–±–∏–≤–∞–µ–º –µ–≥–æ
                if len(paragraph) > max_length:
                    words = paragraph.split(' ')
                    current_paragraph = ""
                    
                    for word in words:
                        if len(current_paragraph + word + ' ') <= max_length:
                            current_paragraph += word + ' '
                        else:
                            if current_paragraph:
                                parts.append(current_paragraph.strip())
                            current_paragraph = word + ' '
                    
                    if current_paragraph:
                        current_part = current_paragraph
                else:
                    current_part = paragraph + '\n\n'
        
        if current_part:
            parts.append(current_part.strip())
        
        return parts
    
    async def error_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫"""
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ {update}: {context.error}")
        
        if update and update.message:
            await update.message.reply_text(
                "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
            )
    
    def run(self) -> None:
        """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
        if not TELEGRAM_BOT_TOKEN:
            logger.error("TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω! –°–æ–∑–¥–∞–π—Ç–µ .env —Ñ–∞–π–ª —Å —Ç–æ–∫–µ–Ω–æ–º.")
            print("‚ùå –û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω —Ç–æ–∫–µ–Ω –±–æ—Ç–∞!")
            print("üìù –°–æ–∑–¥–∞–π—Ç–µ —Ñ–∞–π–ª .env —Å–æ —Å–ª–µ–¥—É—é—â–∏–º —Å–æ–¥–µ—Ä–∂–∏–º—ã–º:")
            print("TELEGRAM_BOT_TOKEN=your_token_here")
            print("\nü§ñ –ü–æ–ª—É—á–∏—Ç—å —Ç–æ–∫–µ–Ω –º–æ–∂–Ω–æ —É @BotFather –≤ Telegram")
            return
        
        # –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
        self.application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
        
        # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("help", self.help_command))
        
        # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—Å–µ—Ö —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
        self.application.add_handler(
            MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message)
        )
        
        # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫
        self.application.add_error_handler(self.error_handler)
        
        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∑–∞–ø—É—Å–∫–µ
        logger.info("ü§ñ –ò–¢–ú–û –†–µ–∫–æ–º–µ–Ω–¥–∞—Ç–µ–ª—å–Ω—ã–π –±–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
        logger.info("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö:")
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        try:
            programs = self.bot_handler.db.get_all_programs()
            courses = self.bot_handler.db.get_all_courses()
            qa_pairs = self.bot_handler.db.get_all_qa_pairs()
            
            logger.info(f"   –ü—Ä–æ–≥—Ä–∞–º–º: {len(programs)}")
            logger.info(f"   –ö—É—Ä—Å–æ–≤: {len(courses)}")
            logger.info(f"   Q&A –ø–∞—Ä: {len(qa_pairs)}")
            
            print("üöÄ –ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω!")
            print(f"üìä –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö: {len(programs)} –ø—Ä–æ–≥—Ä–∞–º–º, {len(courses)} –∫—É—Ä—Å–æ–≤")
            print("‚èπÔ∏è  –ù–∞–∂–º–∏—Ç–µ Ctrl+C –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏")
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
        self.application.run_polling(allowed_updates=Update.ALL_TYPES)

def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    print("ü§ñ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ò–¢–ú–û –†–µ–∫–æ–º–µ–Ω–¥–∞—Ç–µ–ª—å–Ω–æ–≥–æ –±–æ—Ç–∞...")
    
    # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –ª–æ–≥–æ–≤ –µ—Å–ª–∏ –Ω–µ—Ç
    os.makedirs('logs', exist_ok=True)
    
    try:
        bot = ITMOTelegramBot()
        bot.run()
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è  –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
        logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
    except Exception as e:
        print(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
        logger.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}", exc_info=True)

if __name__ == "__main__":
    main() 